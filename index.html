<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ChordWeb üéπ üï∏Ô∏è</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
  :root{ --bg:#0f172a; --fg:#e5e7eb; --card:#111827; --border:#374151; --accent:#2563eb; --muted:#94a3b8; }
  :root[data-theme="light"]{ --bg:#f8fafc; --fg:#0f172a; --card:#ffffff; --border:#e5e7eb; --accent:#2563eb; }
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; overscroll-behavior-y: contain;}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  header{display:flex;align-items:center;gap:10px}
  h1{font-size:18px;margin:0 8px 0 0}
  button,select,input[type="number"],input[type="range"],input[type="text"],a.iconbtn{
    border-radius:14px;border:1px solid var(--border);background:var(--card);color:var(--fg);padding:8px 10px;font-size:14px;text-decoration:none}
  .pill{border-radius:999px}
  .accent{background:var(--accent); color:#fff; border-color:transparent}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .row label{min-width:60px;color:var(--muted);font-size:13px}
  .panel{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:10px;margin-top:10px}
  .cards{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:12px 0 24px}
  @media (max-width:900px){ .cards{grid-template-columns:1fr} }
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:10px;display:flex;gap:12px}
  .iconbtn{width:40px;height:40px;display:inline-flex;align-items:center;justify-content:center;border-radius:999px}
  .small{font-size:12px;color:var(--muted)}
  .notice{color:#fca5a5}

  /* Viz */
  .vizhead{display:flex;align-items:center;gap:8px;margin-bottom:6px;flex-wrap:wrap}
  .viztools{display:flex;align-items:center;gap:8px;margin-left:auto;flex-wrap:wrap}
  svg#sun{width:100%;height:860px;cursor:grab;background:radial-gradient(ellipse at 50% 50%, rgba(255,255,255,.04), transparent 55%)}
  svg#sun:active{cursor:grabbing}
  .tooltip{position:fixed;pointer-events:none;background:#111;border:1px solid #333;color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .08s}

  /* Quick hide for controls in PMI mode */
  .hide{display:none !important}

  /* Explain panel */
  #explainWrap h3{margin:.3rem 0 .6rem;font-size:14px}
  #explainList{display:grid;gap:.35rem}
  .exline{padding:.5rem .6rem;border:1px dashed var(--border);border-radius:12px;font-size:13px;background:rgba(148,163,184,.06)}
  .tag{display:inline-block;margin-left:.4rem;padding:.1rem .45rem;border-radius:999px;border:1px solid var(--border);font-size:11px;background:rgba(37,99,235,.15)}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>ChordWeb</h1>
    <button id="themeBtn" class="iconbtn" title="Toggle theme">üåô</button>
    <div style="flex:1"></div>
    <a class="iconbtn" href="https://github.com/santismo/ChordWeb" target="_blank" rel="noopener" title="GitHub">üï∏Ô∏è</a>
    <button id="openSettings" class="pill">‚öôÔ∏è Settings</button>
    <button id="resetAll" class="pill">‚ü≤ Reset</button>
  </header>

  <!-- Controls -->
  <div class="panel">
    <div class="row">
      <label>Count</label><input id="count" type="number" min="1" max="16" value="4"/>
      <label>Vol</label><input id="vol" type="range" min="0" max="100" value="45"/>
      <label>Musicality</label><span class="small">Friendly</span>
      <input id="spicy" type="range" min="0" max="100" value="0" title="Friendly ‚Üê‚Äî‚Äî‚Äî‚Äî‚Üí Spicy"/>
      <span class="small">Scary</span>
      <label title="Avoid duplicate names in one batch"><input id="noRepeat" type="checkbox" checked/> No repeat</label>
      <label title="For huge scenarios, draw compact mini clusters"><input id="mini" type="checkbox" checked/> Mini Webs</label>
    </div>
    <div class="row" id="selectorRow">
      <label>Root</label><select id="rootSel"><option>All Keys</option></select><button id="rootRnd" class="iconbtn">üé≤</button>
      <span id="baseWrap" class="row" style="gap:10px">
        <label>Base</label><select id="baseSel"><option>All Base Modes</option></select><button id="baseRnd" class="iconbtn">üé≤</button>
      </span>
      <span id="subWrap" class="row" style="gap:10px">
        <label>Sub</label><select id="subSel"><option>All Sub Modes</option></select><button id="subRnd" class="iconbtn">üé≤</button>
      </span>
      <label>Start</label><select id="startSel"><option>(none)</option></select>
      <label>End</label><select id="endSel"><option>(none)</option></select>
    </div>
    <div class="row" style="gap:12px">
      <button id="gen" class="pill accent">üåÄ Generate</button>
      <button id="copy" class="pill">üìã Copy</button>
      <div id="notice" class="notice small"></div>
    </div>
  </div>

  <div id="cards" class="cards"></div>

  <!-- Visual -->
  <div class="panel">
    <div class="vizhead">
      <strong>Web Visual</strong>
      <div id="vizMeta" class="small" style="margin-left:8px"></div>
      <div class="viztools">
        <label>Dot r</label><input id="nodeR" type="range" min="1" max="12" step="1" value="4">
        <label>Gap</label><input id="rowGap" type="range" min="24" max="260" step="1" value="64">
        <label>Mini space</label><input id="miniSpace" type="range" min="0" max="2400" step="1" value="120" title="Distance between mini clusters">
        <label>Mini group by</label>
        <select id="miniGroup" title="How to group mini constellations when All Sub Modes is selected">
          <option value="base" selected>Base</option>
          <option value="sub">Sub (All)</option>
        </select>
        <button id="zoomIn"  class="iconbtn" title="Zoom in">Ôºã</button>
        <button id="zoomOut" class="iconbtn" title="Zoom out">Ôºç</button>
        <button id="zoomReset" class="iconbtn" title="Reset view">‚§æ</button>
        <button id="redraw" class="pill">Rebuild</button>
      </div>
    </div>
    <svg id="sun" viewBox="0 0 1200 860" preserveAspectRatio="xMidYMid meet" aria-label="Constellation">
      <g id="zoomG" transform="translate(0,0) scale(1)">
        <g id="modesG"></g>
        <g id="chartG"></g>
        <g id="selG"></g>
        <g id="pathG"></g>
        <g id="pulseG"></g>
      </g>
    </svg>
    <div class="small"> Hotkeys: G (generate), R (reset), 1‚Äì8 (play).</div>
  </div>

  <!-- Explanations panel (beneath viz) -->
  <div id="explainWrap" class="panel" style="display:none">
    <h3>Modulation / Movement Explanations</h3>
    <div id="explainList"></div>
  </div>
</div>
<div id="tip" class="tooltip"></div>

<!-- Settings -->
<div id="settings" role="dialog" aria-modal="true" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:10000">
  <div style="width:min(880px,92vw);background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px">
    <div style="display:flex;align-items:center;gap:8px">
      <h2 style="margin:0 0 6px 0;font-size:16px">Settings</h2>
      <div style="flex:1"></div>
      <button id="closeSettings" class="iconbtn">‚úñ</button>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
      <div class="panel">
        <div class="row"><label>Load .xlsx</label><input type="file" id="file" accept=".xlsx,.xls"/></div>
        <div class="row"><label>Data URL</label><input id="dataURL" type="text" placeholder="https://.../data.xlsx" style="min-width:320px;flex:1"/><button id="dataURLLoad">Load</button></div>
        <div class="row small">Tip: <code>?xlsx=https://‚Ä¶/file.xlsx</code> autoloads. If CORS blocks it, use file upload.</div>
      </div>
      <div class="panel">
        <div class="row"><strong>Parse stats</strong></div>
        <div id="parseStats" class="small" style="font-family:ui-monospace,Menlo,Consolas,monospace"></div>
      </div>
    </div>

    <!-- PMI block -->
    <div class="panel" style="margin-top:10px">
      <div class="row">
        <label><input type="checkbox" id="pmiToggle"/> Procedural Modal Interchange (no data)</label>
        <span class="small">Borrow diatonic 7th chords from all parallel modes of the selected root.</span>
      </div>
      <div class="row small">
        In PMI mode: Base/Sub controls are hidden; Start/End menus list only PMI chords; the viz shows a ring per mode.
      </div>
    </div>

    <!-- NEW: Modulation explanations toggle -->
    <div class="panel" style="margin-top:10px">
      <div class="row">
        <label><input type="checkbox" id="explainToggle"/> Explain modulations between cards</label>
        <span class="small">Labels like circle-of-fifths, secondary dominant (V/x), tritone sub (‚ô≠II7), chromatic mediant, common-tone, modal interchange, etc.</span>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== Helpers ===== */
const normLabel = s => (s||"").replace(/\s+/g,' ').trim();
function el(id){return document.getElementById(id)}
function val(id){return el(id).value}
const rand = n => Math.floor(Math.random()*n);

/* ===== Music helpers ===== */
const noteToSemi = {
  "C":0,"B#":0,"C#":1,"Db":1,"D":2,"D#":3,"Eb":3,"E":4,"Fb":4,"F":5,"E#":5,
  "F#":6,"Gb":6,"G":7,"G#":8,"Ab":8,"A":9,"A#":10,"Bb":10,"B":11,"Cb":11
};
const CANON = {0:'C',1:'C#',2:'D',3:'Eb',4:'E',5:'F',6:'F#',7:'G',8:'Ab',9:'A',10:'Bb',11:'B'};
const MODE_ORDER = ["Ionian","Dorian","Phrygian","Lydian","Mixolydian","Aeolian","Locrian"];
const MODE_STEPS = {
  ionian:[0,2,4,5,7,9,11],
  dorian:[0,2,3,5,7,9,10],
  phrygian:[0,1,3,5,7,8,10],
  lydian:[0,2,4,6,7,9,11],
  mixolydian:[0,2,4,5,7,9,10],
  aeolian:[0,2,3,5,7,8,10],
  locrian:[0,1,3,5,6,8,10],
};
/* 7th chord qualities by mode degree (parallel-mode diatonic) */
const MODE_QUALS = {
  ionian:     ["maj7","min7","min7","maj7","dom7","min7","min7b5"],
  dorian:     ["min7","min7","maj7","dom7","min7","min7b5","maj7"],
  phrygian:   ["min7","maj7","dom7","min7","min7b5","maj7","min7"],
  lydian:     ["maj7","dom7","min7","min7b5","maj7","min7","min7"],
  mixolydian: ["dom7","min7","min7b5","maj7","min7","min7","maj7"],
  aeolian:    ["min7","min7b5","maj7","min7","min7","maj7","dom7"],
  locrian:    ["min7b5","maj7","min7","min7","maj7","maj7","min7"]
};
/* colors */
const baseCols=["#22c55e","#10b981","#06b6d4","#3b82f6","#6366f1","#a855f7","#ef4444"];
const subCols = ["#ef4444","#f59e0b","#84cc16","#10b981","#06b6d4","#3b82f6","#a855f7"];
function modeRank(s){ s=(s||"").toLowerCase(); for(let i=0;i<MODE_ORDER.length;i++){ if(s.includes(MODE_ORDER[i].toLowerCase())) return i; } return 999; }
function sortModesCW(a,b){ const ra=modeRank(a), rb=modeRank(b); if(ra!==rb) return ra-rb; return (a||"").localeCompare(b||""); }
function displaySubLabel(S){
  let parts=(S||"").trim().split(/\s+/);
  if(parts.length && /^[A-G](?:#|b)?$/i.test(parts[0])) parts=parts.slice(1);
  return parts.join(' ');
}
function subFamilyIndex(S){
  const disp = displaySubLabel(S||"");
  const head = (disp.split(/\s+/)[0]||"").toLowerCase();
  const i = MODE_ORDER.findIndex(m => m.toLowerCase()===head);
  return i>=0 ? i : 0;
}
function subFamilyColor(S){ return subCols[subFamilyIndex(S) % subCols.length]; }

function keySemitone(K){
  const k = (K || "").trim();
  if (Object.prototype.hasOwnProperty.call(noteToSemi, k)) return noteToSemi[k];
  const t = k.replace(/[^A-G#b]/gi, "");
  return noteToSemi[t] ?? 0;
}
function sortKeysChromatic(arr, start='C'){
  const s = keySemitone(start);
  return arr.slice().sort((a,b)=>{
    const da = (keySemitone(a) - s + 12) % 12;
    const db = (keySemitone(b) - s + 12) % 12;
    return da - db;
  });
}

/* === Parsing chord labels (min7b5 / √∏7 / dom7 / maj7 / min7 supported) === */
const romanRe = /^[b‚ô≠]?(?:I|II|III|IV|V|VI|VII)¬∞?$/i;
function parseLabel(s){
  const parts=(s||"").trim().split(/\s+/);
  if(!parts.length) return null;
  const qTok = parts.find(p => /^(maj7|dom7|min7b5|min7|dim7|m7b5|√∏7|7)$/i.test(p));
  let quality = null;
  if(qTok){
    const ql = qTok.toLowerCase();
    quality = (ql==="m7b5"||ql==="√∏7") ? "min7b5" :
              (ql==="7") ? "dom7" : qTok.toLowerCase();
  }
  let numeral=""; let rootTokens=parts;
  if(romanRe.test(parts.at(-1)||"")){ numeral=parts.at(-1); rootTokens=parts.slice(0,-1); }
  let root=rootTokens.filter(t=>!/^maj7|dom7|min7b5|min7|dim7|m7b5|√∏7|7$/i.test(t)).join("");
  if(!quality){
    if(root.endsWith("¬∞")) { root=root.slice(0,-1); quality="dim7"; }
    else if(root.endsWith("m")) { root=root.slice(0,-1); quality="min7"; }
    else if((numeral||"").toLowerCase()==='v') quality="dom7";
    else {
      quality={"i":"maj7","ii":"min7","iii":"min7","iv":"maj7","v":"dom7","vi":"min7","vii":"min7b5"}[(numeral||"").toLowerCase()]||"maj7";
    }
  }
  return [root,quality];
}
function build7th(root,quality){
  const R=noteToSemi[root.replace("‚ôØ","#").replace("‚ô≠","b")] ?? 0;
  const iv={'maj7':[0,4,7,11],'min7':[0,3,7,10],'dom7':[0,4,7,10],'dim7':[0,3,6,9],'min7b5':[0,3,6,10]}[quality]||[0,4,7,11];
  return [iv.map(i=>R+i), R];
}
function chordPCSet(label){ const p=parseLabel(label); if(!p) return new Set(); const [r,q]=p; const [ns]=build7th(r,q); return new Set(ns.map(n=>((n%12)+12)%12)); }
function jaccard(A,B){ let i=0; for(const x of A){ if(B.has(x)) i++; } const u=A.size+B.size-i; return u? i/u : 0; }

/* ===== Families for a (root, base) ===== */
function familiesFor(rootKey, base){
  const baseName = (base || "Ionian").replace(/^[A-G](?:#|b)?\s+/, "");
  const steps = MODE_STEPS[(baseName || "ionian").toLowerCase()] || MODE_STEPS.ionian;
  const R = noteToSemi[rootKey] ?? 0;
  return steps.map(d => `${CANON[(R + d + 1200) % 12]} ${baseName}`);
}

/* ===== Data model (spreadsheet mode) ===== */
const DB={keys:[],data:{},stats:{sheets:0,rows:0,rowsUsed:0,chordCells:0},nodeIndex:new Map()};
function sortSubsModal(a,b){
  const da=displaySubLabel(a), db=displaySubLabel(b);
  const ra=modeRank((da.split(/\s+/)[0]||"")), rb=modeRank((db.split(/\s+/)[0]||""));
  if(ra!==rb) return ra-rb;
  return da.localeCompare(db);
}
function uniqueSubsForBase(k,b){
  const src = Object.keys((DB.data[k]||{})[b]||{}).sort(sortSubsModal);
  const seen=new Set(), out=[];
  for(const s of src){ const disp=displaySubLabel(s); if(!seen.has(disp)){ seen.add(disp); out.push({value:s, disp}); } }
  return out;
}
function ingestXLSX(wb){
  const data={}; const names=wb.SheetNames||[]; let total=0, used=0, chords=0;
  for(const s of names){
    const ws=wb.Sheets[s]; if(!ws) continue;
    const rows=XLSX.utils.sheet_to_json(ws,{header:1,raw:true,blankrows:false});
    if(!rows||rows.length<2) continue;
    total += (rows.length-1);
    const key=(s||"").trim();
    let lastBase="", lastSub="";
    for(let r=1;r<rows.length;r++){
      const row=rows[r]||[];
      const baseCell=(row[1]!=null?(""+row[1]).trim():""); if(baseCell) lastBase=baseCell;
      const subCell =(row[2]!=null?(""+row[2]).trim():""); if(subCell) lastSub=subCell;
      const famCell =(row[3]!=null?(""+row[3]).trim():"");
      const base=lastBase, sub=lastSub; if(!base||!sub) continue;
      const degrees=[];
      for(let c=4;c<600;c++){ const v=row[c]; if(v==null) continue; const s=(""+v).trim(); if(s) degrees.push(s); }
      if(!degrees.length) continue;
      used++; chords += degrees.length;
      (data[key] ||= {})[base] ||= {};
      (data[key][base][sub] ||= []).push({family:famCell, degrees});
    }
  }
  DB.keys=Object.keys(data).sort();
  DB.data=data; DB.stats={sheets:names.length,rows:total,rowsUsed:used,chordCells:chords};
}

/* ===== PMI (Procedural Modal Interchange) ===== */
let PMI=false;
function pmiChordsForRoot(rootKey){
  const R = noteToSemi[rootKey]; if(R==null) return [];
  const out=[];
  MODE_ORDER.forEach((m,mi)=>{
    const steps = MODE_STEPS[m.toLowerCase()];
    const quals = MODE_QUALS[m.toLowerCase()];
    for(let i=0;i<7;i++){
      const pc = (R + steps[i] + 1200) % 12;
      const note = CANON[pc];
      const q = quals[i];
      const label = `${note} ${q}`;
      out.push({ label, key: rootKey, base: `${rootKey} ${m}`, sub: `${rootKey} ${m}`, family: `${note} ${m} ‚Ä¢ ${i+1}` , modeIndex: mi, degree: i });
    }
  });
  const seen=new Set(); return out.filter(o=>{ const k=o.label; if(seen.has(k)) return false; seen.add(k); return true; });
}

<!-- ===== NEW: Modulation explanation engine (expanded) ===== -->

let EXPLAIN=false;

/* helpers for theory heuristics */
const INTERVAL = (a,b)=> (b - a + 12) % 12;
const isDom7 = q => q==="dom7";
const isMin7 = q => q==="min7" || q==="min7b5"; // treat √∏ as minor-ish for some patterns
const isMaj7 = q => q==="maj7";

/* Build diatonic 7ths for a key center (Ionian or Aeolian) */
function diatonicSevenths(rootPc, mode /* "ionian"|"aeolian" */){
  const steps = MODE_STEPS[mode];
  const quals = MODE_QUALS[mode];
  const out = [];
  for(let i=0;i<7;i++){
    const pc = (rootPc + steps[i]) % 12;
    out.push(`${CANON[pc]} ${quals[i]}`);
  }
  return out;
}
/* Precompute all 24 key palettes (major/minor) for pivot detection */
const KEY_PALETTES = (()=>{
  const m = new Map();
  for(let pc=0; pc<12; pc++){
    const M = diatonicSevenths(pc,"ionian");
    const mSet = new Set(M.map(normLabel));
    m.set(`${CANON[pc]} major`, mSet);
    const N = diatonicSevenths(pc,"aeolian");
    const nSet = new Set(N.map(normLabel));
    m.set(`${CANON[pc]} minor`, nSet);
  }
  return m;
})();

/* label builders */
const tag = (s)=>`<span class="tag">${s}</span>`;

/* the brain: explain relationship between two chords A‚ÜíB */
function explainBetween(a,b){
  // a/b come like {label, base, ...}
  const [ar,aq]=parseLabel(a.label)||["C","maj7"];
  const [br,bq]=parseLabel(b.label)||["C","maj7"];
  const aR=noteToSemi[ar], bR=noteToSemi[br];
  const pcA=chordPCSet(a.label), pcB=chordPCSet(b.label);
  const diff = INTERVAL(aR,bR);          // upward interval a‚Üíb
  const fifthDown = (aR + 5) % 12;       // "resolves" target from A if A is dominant
  const thirdUp   = (aR + 4) % 12;       // major third up
  const deceptiveTgt = (aR + 2) % 12;    // classic V‚Üívi in major keys is +2 semitones
  const out=[];

  /* 1) Functional & applied */
  // Circle of fifths (descending 5ths / ascending 4ths)
  if (bR === fifthDown) out.push("circle of fifths (V‚ÜíI)");

  // Secondary dominant: A is dom7 resolving down a fifth to B
  if (isDom7(aq) && bR === fifthDown) out.push(`secondary dominant (V/${br})`);

  // ii‚ÄìV (applied) inference: A is min7 and B is dom7 a 4th above A
  // (B root == A root +5 semitones means A is ii of B)
  if (isMin7(aq) && isDom7(bq) && INTERVAL(aR,bR)===5){
    const target = CANON[(bR + 5) % 12];
    out.push(`applied ii‚ÄìV of ${target} (implied)`);
  }

  // Deceptive: V ‚Üí vi (or V ‚Üí i)
  if (isDom7(aq) && bR === deceptiveTgt) out.push("deceptive resolution (V‚Üívi/i)");

  /* 2) Substitution & jazz */
  // Tritone sub: dom7 to a tritone-related root
  if (isDom7(aq) && diff===6){
    const target = CANON[(bR + 5) % 12];
    out.push(`tritone sub (‚ô≠II7) of V/${target}`);
  }

  // Backdoor: ‚ô≠VII7 ‚Üí I (roots up whole step, dom7 ‚Üí maj7/min)
  if (isDom7(aq) && (INTERVAL(aR,bR)===2) && (isMaj7(bq) || bq==="min7")){
    out.push("backdoor cadence (‚ô≠VII7‚ÜíI)");
  }

  /* 3) Modal mixture & key relations */
  // Parallel modal shift (same root, different quality)
  if (aR===bR && aq!==bq) out.push(`parallel modal shift (${ar}: ${aq}‚Üí${bq})`);

  // Relative key color: Imaj7 ‚Üî vi7 (or i7 ‚Üî ‚ô≠IIImaj7)
  if ((isMaj7(aq) && isMin7(bq) && INTERVAL(aR,bR)===9) ||
      (isMin7(aq) && isMaj7(bq) && INTERVAL(aR,bR)===3)){
    out.push("relative key move (I‚Üîvi or i‚Üî‚ô≠III)");
  }

  // Modal interchange flag (especially in PMI or when bases differ)
  if (PMI || (a.base && b.base && a.base!==b.base)){
    const am = (a.base||"").split(/\s+/).at(-1)||"";
    const bm = (b.base||"").split(/\s+/).at(-1)||"";
    if (am || bm) out.push(`modal interchange (${am}‚Üí${bm})`);
  }

  /* 4) Chromatic families */
  // Chromatic mediant family (¬±3 or ¬±4 or ¬±8 or ¬±9 semitones)
  if ([3,4,8,9].includes(diff)) out.push(`chromatic mediant (${diff}‚Üë)`);
  // Semitone side-step
  if (diff===1 || diff===11) out.push("chromatic side-step (¬±¬Ω)");

  /* 5) Common materials */
  // Common tones (list up to 3)
  const shared=[...pcA].filter(x=>pcB.has(x));
  if (shared.length>=3){
    out.push(`rich common-tone (${shared.map(x=>CANON[x]).slice(0,3).join(", ")})`);
  } else if (shared.length>=2){
    out.push(`common-tone (${shared.map(x=>CANON[x]).slice(0,3).join(", ")})`);
  } else if (shared.length===1){
    out.push(`single common-tone (${CANON[shared[0]]})`);
  }

  // Common-chord (pivot) detection: both chords diatonic to same key (major/minor)
  const aLab = normLabel(a.label), bLab = normLabel(b.label);
  for(const [kName,set] of KEY_PALETTES.entries()){
    if(set.has(aLab) && set.has(bLab)){ out.push(`common-chord pivot in ${kName}`); break; }
  }

  /* 6) Symmetry hubs */
  // Diminished 7th reinterpretation potential
  if (aq==="dim7") out.push("enharmonic pivot (¬∞7 can resolve to 4 keys)");
  // Augmented triad isn‚Äôt in 7ths set; skip

  /* 7) Fallback descriptors */
  if(!out.length){
    if (diff===7) out.push("fifths motion (‚Üë5th)");
    else if (diff===0 && aq===bq) out.push("static color (same chord class)");
    else out.push(`non-functional/planar move (${ar}‚Üí${br})`);
  }
  return out;
}

function renderExplanations(){
  const wrap=el('explainWrap'), list=el('explainList');
  if(!EXPLAIN || !CURRENT.length){ wrap.style.display='none'; list.innerHTML=''; return; }
  const rows=[];
  for(let i=0;i<CURRENT.length-1;i++){
    const A=CURRENT[i], B=CURRENT[i+1];
    const methods=explainBetween(A,B);
    rows.push(
      `<div class="exline"><strong>#${i+1} ‚Üí #${i+2}</strong> ‚Ä¢ ${A.label} ‚Üí ${B.label} ${methods.map(tag).join(" ")}</div>`
    );
  }
  list.innerHTML=rows.join('');
  wrap.style.display = rows.length ? 'block' : 'none';
}


/* ===== UI: selectors ===== */
function updateSelectors(){
  const rootSel=document.getElementById('rootSel');
  rootSel.innerHTML = `<option>All Keys</option>` + DB.keys.map(k=>`<option>${k}</option>`).join("");
  document.getElementById('baseSel').innerHTML=`<option>All Base Modes</option>`;
  document.getElementById('subSel').innerHTML = `<option>All Sub Modes</option>`;
  refreshChoices();
}
function onRootChange(){
  const k=val('rootSel');
  if(PMI){
    refreshChoicesFromPMI();
    render();
    return;
  }
  const baseSel=document.getElementById('baseSel');
  const subSel=document.getElementById('subSel');
  if(k==="All Keys"){ baseSel.innerHTML=`<option>All Base Modes</option>`; subSel.innerHTML=`<option>All Sub Modes</option>`; }
  else {
    const bases=Object.keys(DB.data[k]||{}).sort(sortModesCW);
    baseSel.innerHTML = `<option>All Base Modes</option>` + bases.map(b=>`<option>${b}</option>`).join("");
    subSel.innerHTML = `<option>All Sub Modes</option>`;
  }
  SEL_CHOICE.clear();
  render();
}
function onBaseChange(){
  if(PMI){ render(); return; }
  const k=val('rootSel'), b=val('baseSel');
  const subSel=document.getElementById('subSel');
  if(k==="All Keys" || b==="All Base Modes"){ subSel.innerHTML=`<option>All Sub Modes</option>`; }
  else{
    const subs=uniqueSubsForBase(k,b);
    subSel.innerHTML = `<option>All Sub Modes</option>` + subs.map(s=>`<option value="${s.value}">${s.disp}</option>`).join("");
  }
  SEL_CHOICE.clear();
  render();
}

/* Start/End options */
function refreshChoices(){ refreshChoicesFromViz(); }
function refreshChoicesFromViz(){
  if(PMI){ refreshChoicesFromPMI(); return; }
  const labels = Array.from(DB.nodeIndex.keys()).sort();
  const opts = ['(none)', ...labels].map(v => `<option>${v}</option>`).join('');
  const keep = (selId) => {
    const sel = el(selId);
    const prev = sel.value || '(none)';
    sel.innerHTML = opts;
    sel.value = labels.includes(prev) ? prev : '(none)';
  };
  keep('startSel'); keep('endSel');
}
function refreshChoicesFromPMI(){
  const k = val('rootSel');
  const optsArr = (k && k!=="All Keys") ? pmiChordsForRoot(k).map(o=>o.label).sort() : [];
  const opts = ['(none)', ...optsArr].map(v=>`<option>${v}</option>`).join('');
  ['startSel','endSel'].forEach(id=>{ const s=el(id); const prev=s.value||'(none)'; s.innerHTML=opts; s.value = optsArr.includes(prev)?prev:'(none)'; });
}

/* ===== Sampling ===== */
let CURRENT=[];
function bucketsFor(k,b,s){
  const keys=(k==="All Keys")? DB.keys : [k];
  const out=[];
  for(const K of keys){
    for(const [B,subs] of Object.entries(DB.data[K]||{})){
      if(b!=="All Base Modes" && B!==b) continue;
      for(const [S,rows] of Object.entries(subs)){
        if(s!=="All Sub Modes" && S!==s) continue;
        for(const row of rows){
          const degs=(row.degrees||[]).filter(Boolean);
          if(degs.length){ out.push({key:K,base:B,sub:S,family:row.family,row:degs}); }
        }
      }
    }
  }
  return out;
}

function sample(n){
  const spicy = parseInt(val('spicy'))/100;
  const startSel = val('startSel');
  const endSel   = val('endSel');
  const startOpt = (startSel && startSel !== "(none)") ? normLabel(startSel) : null;
  const endOpt   = (endSel   && endSel   !== "(none)") ? normLabel(endSel)   : null;

  // Build pool from current mode (PMI or Data)
  let pool=[];
  if(PMI){
    const k = val('rootSel');
    if(!k || k==="All Keys"){ el('notice').textContent="Pick a specific root for PMI."; return []; }
    pool = pmiChordsForRoot(k).map(p=>({ ...p }));
  }else{
    const k = val('rootSel'), b = val('baseSel'), s = val('subSel');
    const groups = bucketsFor(k,b,s);
    for (const g of groups){
      g.row.forEach((label,ci)=>{
        const lab = normLabel(label);
        pool.push({label: lab, key:g.key, base:g.base, sub:g.sub, family:g.family, ci});
      });
    }
  }

  if (!pool.length) {
    el('notice').textContent = "No chords available for this selection.";
    return [];
  }

  // Start/End validation
  const allowed = new Set(pool.map(p => p.label));
  if (startOpt && !allowed.has(startOpt)) { el('notice').textContent = `Start "${startOpt}" isn‚Äôt available for these settings.`; return []; }
  if (endOpt && !allowed.has(endOpt))   { el('notice').textContent = `End "${endOpt}" isn‚Äôt available for these settings.`; return []; }

  // Shuffle
  for (let i = pool.length-1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [pool[i], pool[j]] = [pool[j], pool[i]]; }

  const used = new Set();
  const out = [];
  function popExact(lab){
    const idx = pool.findIndex(o => o.label === lab);
    if (idx < 0) return null;
    return pool.splice(idx,1)[0];
  }
  function biasedPick(prev, bannedLabel){
    if (!pool.length) return null;
    const candidates = bannedLabel ? pool.filter(o => o.label !== bannedLabel) : pool.slice();
    if (!candidates.length) return null;

    if (!prev || spicy <= 0) {
      const pick = candidates[candidates.length-1];
      const idx = pool.findIndex(o => o === pick);
      return pool.splice(idx,1)[0];
    }
    const A = chordPCSet(prev.label);
    const kTop = Math.min(12, candidates.length);
    const tail = candidates.slice(-kTop).map((o, i) => ({
      poolIdx: pool.findIndex(p => p === candidates[candidates.length-kTop+i]),
      obj: o,
      sc: jaccard(A, chordPCSet(o.label))
    })).sort((x,y)=>y.sc-x.sc);

    const top = Math.max(1, Math.round(1 + spicy*5));
    const choice = tail[Math.floor(Math.random() * Math.min(top, tail.length))];
    return pool.splice(choice.poolIdx, 1)[0];
  }

  let startPick=null, endPick=null;
  if (startOpt) { startPick = popExact(startOpt); out.push(startPick); used.add(startPick.label); }
  if (endOpt && (!startPick || endOpt !== startPick.label)) { endPick = popExact(endOpt); }

  const banEndLabel = endPick ? endPick.label : null;
  const want = Math.max(1, n - (endPick ? 1 : 0));
  while (out.length < want) {
    const prev = out[out.length-1];
    const pick = biasedPick(prev, banEndLabel);
    if (!pick) break;
    if (!el('noRepeat').checked || !used.has(pick.label)) { out.push(pick); used.add(pick.label); }
  }
  if (endPick) out.push(endPick);

  el('notice').textContent = out.length ? "" : "Couldn‚Äôt build a sequence with these constraints.";
  return out;
}

/* ===== Cards & audio ===== */
let audioCtx=null; function ctx(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); return audioCtx; }
function playChord(notes,gain=0.45,seconds=0.9){
  const ac=ctx(); const now=ac.currentTime+0.01;
  const comp=ac.createDynamicsCompressor(); comp.threshold.value=-24; comp.knee.value=30; comp.ratio.value=12; comp.attack.value=0.003; comp.release.value=0.25;
  const master=ac.createGain(); const vol=Math.pow(Math.max(0,Math.min(1,gain)),1.6); master.gain.value=vol; comp.connect(master); master.connect(ac.destination);
  const base=60; const a=0.02,d=0.03,s=0.85,r=0.20; const end=now+seconds;
  for(const x of notes){
    const osc=ac.createOscillator(); const g=ac.createGain(); const hz=440*Math.pow(2,((base+(x%12))-69)/12);
    osc.type='sine'; osc.frequency.setValueAtTime(hz, now);
    g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.6/Math.sqrt(notes.length), now+a);
    g.gain.exponentialRampToValueAtTime(0.6/Math.sqrt(notes.length)*s, now+a+d);
    g.gain.setValueAtTime(0.6/Math.sqrt(notes.length)*s, end-r); g.gain.exponentialRampToValueAtTime(0.0001, end);
    osc.connect(g); g.connect(comp); osc.start(now); osc.stop(end+0.02);
  }
}
function drawKeys(notes, rootPC){
  const onset=new Set((notes||[]).map(n=>((n%12)+12)%12));
  const NS="http://www.w3.org/200/svg", W=420,H=110; // typo-proofing var not used
  const svg=document.createElementNS("http://www.w3.org/2000/svg","svg");
  svg.setAttribute("viewBox",`0 0 ${W} ${H}`);

  const keys=[], whites=[]; let count=0, midi=48;
  while(count<22){ const pc=((midi%12)+12)%12; if(![1,3,6,8,10].includes(pc)){ whites.push(midi); count++; } midi++; }
  const ww=W/22;

  whites.forEach((m,i)=>{
    const pc=((m%12)+12)%12; const x=i*ww;
    const r=document.createElementNS("http://www.w3.org/2000/svg","rect");
    r.setAttribute("x",x); r.setAttribute("y",0); r.setAttribute("width",ww); r.setAttribute("height",H);
    r.setAttribute("fill", onset.has(pc) ? "#86efac" : "#ffffff"); r.setAttribute("stroke","#222");
    svg.appendChild(r);
    keys.push({midi:m, pc, isBlack:false, x, w:ww});
  });

  for(let n=48;n<84;n++){
    const pc=((n%12)+12)%12;
    if([1,3,6,8,10].includes(pc)){
      const wi = whites.findIndex(w=>w>n) - 1;
      if(wi>=0){
        const x = wi*ww + ww*0.65;
        const r=document.createElementNS("http://www.w3.org/2000/svg","rect");
        r.setAttribute("x",x); r.setAttribute("y",0); r.setAttribute("width",ww*0.6); r.setAttribute("height",H*0.65);
        r.setAttribute("fill", onset.has(pc) ? "#86efac" : "#111"); r.setAttribute("stroke","#222"); r.setAttribute("rx","2"); r.setAttribute("ry","2");
        svg.appendChild(r);
        keys.push({midi:n, pc, isBlack:true, x, w:ww*0.6});
      }
    }
  }

  const rpc = ((rootPC%12)+12)%12;
  const candidates = keys.filter(k => k.pc===rpc);
  if(candidates.length){
    const center = W/2; candidates.sort((a,b)=>Math.abs((a.x+a.w/2)-center) - Math.abs((b.x+b.w/2)-center));
    const k0 = candidates[0]; const cx = k0.x + k0.w/2; const cy = k0.isBlack ? (H*0.22) : (H-8);
    const dot=document.createElementNS("http://www.w3.org/2000/svg","circle");
    dot.setAttribute("cx",cx); dot.setAttribute("cy",cy); dot.setAttribute("r",5); dot.setAttribute("fill","#60a5fa");
    dot.setAttribute("stroke","#1e3a8a"); dot.setAttribute("stroke-width","1.5"); dot.setAttribute("pointer-events","none");
    svg.appendChild(dot);
  }
  return svg;
}
function renderCards(seq){
  CURRENT=seq.slice();
  SEL_CHOICE.clear();
  const cont=el('cards'); cont.innerHTML="";
  const vol=parseInt(val('vol'))/100;
  seq.forEach((o,i)=>{
    const [root,q]=parseLabel(o.label); const [notes,R]=build7th(root,q);
    const card=document.createElement('div'); card.className="card";
    const meta=document.createElement('div'); meta.style.flex="0 0 160px"; meta.innerHTML=`<h3>#${i+1}</h3><div>${o.label}</div><div class="small">${PMI?(`${o.key} ‚Ä¢ PMI ‚Ä¢ ${o.base}`):(`${o.key} ‚Ä¢ ${o.base} ‚Ä¢ ${displaySubLabel(o.sub)}`)}${o.family?(' ‚Ä¢ '+o.family):''}</div>`;
    const img=document.createElement('div'); img.style.flex="1"; img.appendChild(drawKeys(notes, R%12));
    const btns=document.createElement('div'); btns.style.display="flex"; btns.style.flexDirection="column"; btns.style.gap="8px"; btns.style.width="120px";
    const play=document.createElement('button'); play.textContent="‚ñ∂Ô∏è Play"; play.onclick=()=>{ ctx().resume(); playChord(notes,vol); pulseByLabel(o.label); };
    btns.append(play);
    card.append(meta,img,btns); cont.append(card);
  });
  showSelectionOverlay(); drawSelectionPath();
  renderExplanations(); // <= update explanations when cards change
}

/* ===== SVG / Rendering ===== */
const svg=el('sun'), gZoom=el('zoomG'), gModes=el('modesG'), gChart=el('chartG'), gSel=el('selG'), gPath=el('pathG'), gPulse=el('pulseG');
const W=1200,H=860,CX=W/2,CY=H/2;
function mk(tag,attr){ const e=document.createElementNS('http://www.w3.org/2000/svg',tag); for(const [k,v] of Object.entries(attr||{})) e.setAttribute(k,v); return e; }
function polar(r,a){ const rad=a*Math.PI/180; return [CX + r*Math.cos(rad), CY + r*Math.sin(rad)]; }
function colorFor(B,S,ri){ if(ri!=null) return ["#7dd3fc","#93c5fd","#a7f3d0","#fde68a","#fca5a5","#c7d2fe","#99f6e4","#fecaca"][ri%8]; return baseCols[Math.max(0,modeRank(B))%baseCols.length]; }

let SEL_POS=new Map();
let SEL_CHOICE=new Map();
function node(title,x,y,r,fill){
  const d=mk('circle',{cx:x,cy:y,r:r,fill:fill||"#93c5fd",stroke:"#0b1220","stroke-width":2,opacity:.98,class:"n","data-tip":title});
  return d;
}
function showSelectionOverlay(){
  SEL_POS=new Map();
  while(gSel.firstChild) gSel.removeChild(gSel.firstChild);
  const seq=CURRENT; if(!seq||!seq.length) return;

  seq.forEach((o,i)=>{
    const keyLab = normLabel(o.label);
    const plist=DB.nodeIndex.get(keyLab)||[];
    if(!plist.length) return;
    let idx = SEL_CHOICE.has(keyLab) ? SEL_CHOICE.get(keyLab) : rand(plist.length);
    if(idx>=plist.length) idx = plist.length-1;
    SEL_CHOICE.set(keyLab, idx);
    const p = plist[idx];
    SEL_POS.set(keyLab,p);

    const dot = mk('circle', {
      cx:p.x, cy:p.y, r:8,
      fill:"#fff", stroke:"#0b1220", "stroke-width":2,
      class:"n", "data-tip":`#${i+1} ‚Ä¢ ${o.label}`
    });
    const num = mk('text', {
      x:p.x, y:p.y+4, 'text-anchor':'middle',
      style:"font:700 11px system-ui; fill:#000; paint-order:stroke; stroke:#fff; stroke-width:2.5px"
    });
    num.textContent = (i<9)?(i+1):'‚Ä¢';

    dot.addEventListener('click', ()=>pulseAt(p.x,p.y));
    num.addEventListener('click', ()=>pulseAt(p.x,p.y));

    gSel.appendChild(dot);
    gSel.appendChild(num);
  });
}

function drawSelectionPath(){
  while(gPath.firstChild) gPath.removeChild(gPath.firstChild);
  const seq=CURRENT; if(!seq||seq.length<2) return;
  const pts=seq.map(o=>{ const e=SEL_POS.get(normLabel(o.label)); return e? `${e.x},${e.y}`: null; }).filter(Boolean).join(' ');
  if(!pts) return;
  const glow=mk('polyline',{points:pts,fill:'none',stroke:'rgba(34,211,238,.35)',"stroke-width":9,"stroke-linecap":"round","stroke-linejoin":"round"});
  const line=mk('polyline',{points:pts,fill:'none',stroke:'rgba(34,211,238,.9)',"stroke-width":3,"stroke-linecap":"round","stroke-linejoin":"round"});
  gPath.appendChild(glow); gPath.appendChild(line);
}
function pulseAt(x,y){
  const ring=mk('circle',{cx:x,cy:y,r:9,fill:'none',stroke:'#22d3ee','stroke-width':3,opacity:.95});
  gPulse.appendChild(ring);
  let r=9,op=.95,c=0; (function tick(){ c++; r+=1.8; op*=.92; ring.setAttribute('r',r); ring.setAttribute('opacity',op); if(c<18) requestAnimationFrame(tick); else gPulse.removeChild(ring); })();
}
function pulseByLabel(label){
  const e=SEL_POS.get(normLabel(label)) || (DB.nodeIndex.get(normLabel(label))||[])[0]; if(e) pulseAt(e.x,e.y);
}

/* Degree helpers for spreadsheet mode */
function degreesForFamilyExact(K,B,S,fam){
  const subs = ((DB.data[K]||{})[B]||{});
  const rows = subs[S] || [];
  const hit = rows.find(r => normLabel(r.family) === normLabel(fam));
  return hit && Array.isArray(hit.degrees) ? hit.degrees.map(normLabel) : [];
}

/* ===== Main render ===== */
function render(){
  [gModes,gChart,gSel,gPath,gPulse].forEach(g=>{ while(g.firstChild) g.removeChild(g.firstChild); });
  DB.nodeIndex.clear();

  const nodeR=parseInt(val('nodeR')), gap=parseInt(val('rowGap'));
  const mini = el('mini').checked, miniBy = el('miniGroup').value;
  const miniSpace = parseInt(val('miniSpace'));
  const ring0=110, ringSub=ring0+64, ringFam=ringSub+36;
  const a0=-90;

  if(PMI){
    const k = val('rootSel');
    const centerLabel = (k && k!=="All Keys") ? k : "Pick a Root";
    gModes.appendChild(node(centerLabel, CX, CY, 16, "#fff"));

    if(!k || k==="All Keys"){ el('vizMeta').textContent="PMI ‚Ä¢ (no root chosen)"; refreshChoicesFromPMI(); renderExplanations(); return; }

    const step = 360/7;
    MODE_ORDER.forEach((m,mi)=>{
      const a = a0 + mi*step;
      const [cx,cy] = polar(220 + miniSpace*0.6, a);
      gModes.appendChild(node(m, cx, cy, 7.5, baseCols[mi%7]));

      const degSteps = (MODE_STEPS[m.toLowerCase()]||[]);
      const quals    = (MODE_QUALS[m.toLowerCase()]||[]);
      const famColor = baseCols[mi%7];
      for(let di=0; di<7; di++){
        const rr = 74 + 22 + di*(gap*0.75);
        const [x,y]=[ cx + Math.cos((a-90)*Math.PI/180)*rr, cy + Math.sin((a-90)*Math.PI/180)*rr ];
        const pc = (keySemitone(k) + degSteps[di] + 1200) % 12;
        const label = `${CANON[pc]} ${quals[di]}`;
        const d=node(label,x,y,nodeR, famColor);
        gChart.appendChild(d);
        (DB.nodeIndex.get(label) || DB.nodeIndex.set(label,[]), DB.nodeIndex.get(label)).push({x,y});
      }
    });

    el('vizMeta').textContent = `PMI ‚Ä¢ ${k}`;
    refreshChoicesFromPMI();
    showSelectionOverlay(); drawSelectionPath();
    renderExplanations();
    return;
  }

  // ===== Spreadsheet render paths =====
  const k=val('rootSel'), b=val('baseSel'), s=val('subSel');

  const scenario = (k!=="All Keys" && b!=="All Base Modes" && s!=="All Sub Modes") ? 1 :
                   (k!=="All Keys" && b!=="All Base Modes" && s==="All Sub Modes") ? 2 :
                   (k!=="All Keys" && b==="All Base Modes" && s==="All Sub Modes") ? 3 : 0;

  const centerLabel = (scenario===1)? displaySubLabel(s) : (scenario===2? `${k} ${b.replace(/^[A-G](?:#|b)?\s+/,"")}` : (scenario===3? k : "All Keys"));
  gModes.appendChild(node(centerLabel, CX, CY, 16, "#fff"));

  if(scenario===1){
    const famOrder=familiesFor(k,b);
    const rows = (((DB.data[k]||{})[b]||{})[s]||[]);
    const famMap=new Map(); rows.forEach(r=>{ if(r.family) famMap.set(normLabel(r.family), r.degrees.map(normLabel)); });
    const step=360/7; const aStart=-90;
    { const [sx,sy]=polar(ringSub,aStart); gModes.appendChild(node(displaySubLabel(s), sx,sy,7, "#93c5fd")); }
    for(let i=0;i<7;i++){
      const a=aStart + i*step;
      const fam=famOrder[i];
      const [fx,fy]=polar(ringFam,a);
      gModes.appendChild(node(fam, fx,fy,7, baseCols[i%7]));
      const degs=famMap.get(normLabel(fam)) || (rows[0]?.degrees||[]).map(normLabel);
      for(let di=0; di<Math.min(7,degs.length); di++){
        const [x,y]=polar(ringFam+30+di*gap, a);
        const lab=normLabel(degs[di]);
        const d=node(lab,x,y,nodeR, colorFor(b,s,di));
        gChart.appendChild(d);
        (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
      }
    }
  }
  else if(scenario===2){
    const subsUnique = uniqueSubsForBase(k,b);
    const useSubColors = true;
    if(el('mini').checked && el('miniGroup').value==='sub'){
      const step=360/Math.max(1,subsUnique.length);
      const ringCluster = 200 + parseInt(val('miniSpace')) * 1.4;
      subsUnique.forEach((obj,si)=>{
        const S=obj.value, Slabel=obj.disp;
        const a=a0+si*step; const [cx,cy]=polar(ringCluster,a);
        gModes.appendChild(node(Slabel, cx, cy, 7.2, useSubColors ? subFamilyColor(S) : "#a78bfa"));

        const rows = (((DB.data[k]||{})[b]||{})[S]||[]);
        const famOrder=familiesFor(k,b);
        const famMap=new Map(); rows.forEach(r=>{ if(r.family) famMap.set(normLabel(r.family), r.degrees.map(normLabel)); });

        for(let fi=0; fi<7; fi++){
          const aa = (a-90) + fi*(360/7);
          const [fx,fy]=[ cx + Math.cos(aa*Math.PI/180)*74, cy + Math.sin(aa*Math.PI/180)*74 ];
          gModes.appendChild(node(famOrder[fi], fx,fy,6, baseCols[fi%7]));
          const degs=famMap.get(normLabel(famOrder[fi])) || (rows[fi]?.degrees||rows[0]?.degrees||[]).map(normLabel);
          for(let di=0; di<Math.min(7,degs.length); di++){
            const rr = 74 + 20 + di*(parseInt(val('rowGap'))*0.75);
            const [x,y]=[ cx + Math.cos(aa*Math.PI/180)*rr, cy + Math.sin(aa*Math.PI/180)*rr ];
            const lab=normLabel(degs[di]);
            const d=node(lab,x,y,parseInt(val('nodeR')), useSubColors ? subFamilyColor(S) : colorFor(b,S,di));
            gChart.appendChild(d);
            (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
          }
        }
      });
    } else {
      const total=7*subsUnique.length; const step=360/Math.max(1,total);
      let si=0;
      subsUnique.forEach(({value:S, disp})=>{
        const rows = (((DB.data[k]||{})[b]||{})[S]||[]);
        const famOrder=familiesFor(k,b);
        const famMap=new Map(); rows.forEach(r=>{ if(r.family) famMap.set(normLabel(r.family), r.degrees.map(normLabel)); });
        for(let fi=0; fi<7; fi++){
          const a=a0 + (si*step);
          const [sx,sy]=polar(ring0, a);
          gModes.appendChild(node(disp, sx,sy,4.8, subFamilyColor(S)));
          const fam=famOrder[fi];
          const [fx,fy]=polar(ring0+28, a);
          gModes.appendChild(node(fam, fx,fy,6.2, baseCols[fi%7]));
          const degs=famMap.get(normLabel(fam)) || (rows[fi]?.degrees||rows[0]?.degrees||[]).map(normLabel);
          for(let di=0; di<Math.min(7,degs.length); di++){
            const [x,y]=polar(ring0+28+26+di*parseInt(val('rowGap')), a);
            const lab=normLabel(degs[di]);
            const d=node(lab,x,y,parseInt(val('nodeR')), subFamilyColor(S));
            gChart.appendChild(d);
            (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
          }
          si++;
        }
      });
    }
  }
  else if(scenario===3){
    const bases = Object.keys(DB.data[k]||{}).sort(sortModesCW);
    const step=360/Math.max(1,bases.length);
    const ringCluster=200 + parseInt(val('miniSpace')) * 1.4;
    if(el('mini').checked){
      bases.forEach((B,bi)=>{
        const a=a0+bi*step; const [cx,cy]=polar(ringCluster,a);
        gModes.appendChild(node(`${k} ${B.replace(/^[A-G](?:#|b)?\s+/,"")}`, cx, cy, 7.5, "#22c55e"));
        const subsU = uniqueSubsForBase(k,B);
        const st=360/Math.max(1,7*subsU.length);
        let blockStart = 0;
        subsU.forEach(({value:S, disp})=>{
          const aSub = (a-90) + (blockStart+3.5)*st;
          const [sx,sy]=[ cx + Math.cos(aSub*Math.PI/180)*56, cy + Math.sin(aSub*Math.PI/180)*56 ];
          gModes.appendChild(node(disp, sx,sy,4.2, subFamilyColor(S)));

          const rows = (((DB.data[k]||{})[B]||{})[S]||[]);
          const famOrder=familiesFor(k,B);
          const famMap=new Map(); rows.forEach(r=>{ if(r.family) famMap.set(normLabel(r.family), r.degrees.map(normLabel)); });

          for(let fi=0; fi<7; fi++){
            const aa = (a-90) + (blockStart+fi)*st;
            const [fx,fy]=[ cx + Math.cos(aa*Math.PI/180)*84, cy + Math.sin(aa*Math.PI/180)*84 ];
            gModes.appendChild(node(famOrder[fi], fx,fy,6, baseCols[fi%7]));
            const degs=famMap.get(normLabel(famOrder[fi])) || (rows[fi]?.degrees||rows[0]?.degrees||[]).map(normLabel);
            for(let di=0; di<Math.min(7,degs.length); di++){
              const rr = 84 + 22 + di*(parseInt(val('rowGap'))*0.75);
              const [x,y]=[ cx + Math.cos(aa*Math.PI/180)*rr, cy + Math.sin(aa*Math.PI/180)*rr ];
              const lab=normLabel(degs[di]);
              const d=node(lab,x,y,parseInt(val('nodeR')), subFamilyColor(S));
              gChart.appendChild(d);
              (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
            }
          }
          blockStart += 7;
        });
      });
    } else {
      const groups=[];
      for(const [B,subs] of Object.entries(DB.data[k]||{})){
        for(const [S,rows] of Object.entries(subs)) groups.push({B,S,rows});
      }
      const step2=360/Math.max(1,groups.length);
      groups.forEach((G,gi)=>{
        const a=a0+gi*step2;
        for(let r=0; r<G.rows.length; r++){
          const row=G.rows[r];
          for(let di=0; di<Math.min(7,row.degrees.length); di++){
            const [x,y]=polar(130 + r*10 + di*parseInt(val('rowGap')), a);
            const lab=normLabel(row.degrees[di]);
            const d=node(lab,x,y,parseInt(val('nodeR')), subFamilyColor(G.S));
            gChart.appendChild(d);
            (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
          }
        }
      });
    }
  }
  else if (k==="All Keys" && b==="All Base Modes" && s==="All Sub Modes" && el('mini').checked) {
    const keys = sortKeysChromatic(DB.keys, 'C');
    const keyStep = 360/Math.max(1, keys.length);
    const ringCluster = 240 + parseInt(val('miniSpace')) * 1.35;

    const nodeR = parseInt(val('nodeR'));
    const gapVal = parseInt(val('rowGap'));

    keys.forEach((K,ki)=>{
      const aKey = a0 + ki*keyStep;
      const [ux,uy] = polar(ringCluster, aKey);
      gModes.appendChild(node(K, ux, uy, 8.5, "#fff"));

      const bases = Object.keys(DB.data[K]||{}).sort(sortModesCW);
      const baseStep = 360/Math.max(1, bases.length);
      const rBase = 74;

      bases.forEach((B,bi)=>{
        const aBase = (aKey-90) + bi*baseStep;
        const [bx,by] = [ ux + Math.cos(aBase*Math.PI/180)*rBase, uy + Math.sin(aBase*Math.PI/180)*rBase ];
        gModes.appendChild(node(B.replace(/^[A-G](?:#|b)?\s+/,""), bx, by, 6.2, baseCols[bi%7]));

        const subsU = uniqueSubsForBase(K, B);
        const subStep = (baseStep) / Math.max(1, subsU.length);
        const rSub = rBase + 28;

        subsU.forEach((obj, si)=>{
          const S = obj.value, Slabel = obj.disp;
          const aSub = aBase + si*subStep;
          const [sx,sy] = [ ux + Math.cos(aSub*Math.PI/180)*rSub, uy + Math.sin(aSub*Math.PI/180)*rSub ];
          gModes.appendChild(node(Slabel, sx, sy, 4.8, subFamilyColor(S)));

          const famOrder = familiesFor(K, B);
          const famStep = subStep / 7;
          const rFam = rSub + 22;

          for (let fi=0; fi<7; fi++){
            const aFam = aSub + fi*famStep;
            const [fx,fy] = [ ux + Math.cos(aFam*Math.PI/180)*rFam, uy + Math.sin(aFam*Math.PI/180)*rFam ];
            gModes.appendChild(node(famOrder[fi], fx, fy, 4.2, baseCols[fi%7]));

            const degrees = degreesForFamilyExact(K, B, S, famOrder[fi]);
            for (let di=0; di<degrees.length; di++){
              const rr = rFam + 16 + di*(gapVal*0.65);
              const xx = ux + Math.cos(aFam*Math.PI/180)*rr;
              const yy = uy + Math.sin(aFam*Math.PI/180)*rr;
              const lab = normLabel(degrees[di]);
              const d = node(lab, xx, yy, nodeR, subFamilyColor(S));
              gChart.appendChild(d);
              (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x:xx,y:yy});
            }
          }
        });
      });
    });

  } else {
    const keysOrdered = (k==="All Keys") ? sortKeysChromatic(DB.keys, 'C') : [k];
    const groups=[];
    for (const K of keysOrdered){
      for (const [B,subs] of Object.entries(DB.data[K]||{})){
        for (const [S,rows] of Object.entries(subs)) groups.push({K,B,S,rows});
      }
    }
    const step=360/Math.max(1,groups.length);
    groups.forEach((G,gi)=>{
      const a=a0+gi*step;
      for(let r=0; r<G.rows.length; r++){
        const row=G.rows[r];
        for(let di=0; di<Math.min(7,row.degrees.length); di++){
          const [x,y]=polar(130 + r*10 + di*gap, a);
          const lab=normLabel(row.degrees[di]);
          const d=node(lab,x,y,parseInt(val('nodeR')), subFamilyColor(G.S));
          gChart.appendChild(d);
          (DB.nodeIndex.get(lab) || DB.nodeIndex.set(lab,[]), DB.nodeIndex.get(lab)).push({x,y});
        }
      }
    });
  }

  el('vizMeta').textContent = `${k} ‚Ä¢ ${b} ‚Ä¢ ${s}`;
  showSelectionOverlay();
  drawSelectionPath();
  refreshChoicesFromViz();
  renderExplanations(); // <= update explanations on viz change too
}

/* ===== Misc UI ===== */
el('openSettings').onclick=()=>{ el('settings').style.display='flex'; };
el('closeSettings').onclick=()=>{ el('settings').style.display='none'; };

el('themeBtn').onclick=()=>{ const root=document.documentElement; const light=root.getAttribute('data-theme')==='light'; root.setAttribute('data-theme', light?'dark':'light'); el('themeBtn').textContent = light ? 'üåô' : '‚òÄÔ∏è'; };

el('rootSel').onchange = onRootChange;
el('baseSel').onchange = onBaseChange;
el('subSel').onchange  = ()=>{ SEL_CHOICE.clear(); render(); };
['nodeR','rowGap','mini','miniSpace','miniGroup'].forEach(id => { el(id).oninput=render; el(id).onchange=render; });

el('gen').onclick=()=>{ const n=Math.max(1,Math.min(16,parseInt(val('count')||"4"))); const seq=sample(n); el('notice').textContent=seq.length? "":"No chords for this selection."; renderCards(seq); };
el('copy').onclick=async()=>{ const txt=CURRENT.map(x=>x.label).join(', '); try{ await navigator.clipboard.writeText(txt); el('notice').textContent="Copied."; setTimeout(()=>el('notice').textContent="",1000);}catch(e){ el('notice').textContent="Copy failed."; } };
el('resetAll').onclick=()=>{ el('count').value=4; el('vol').value=45; el('spicy').value=0; el('noRepeat').checked=true; el('mini').checked=true; el('miniSpace').value=120; el('miniGroup').value='base'; el('rootSel').value='All Keys'; el('baseSel').innerHTML=`<option>All Base Modes</option>`; el('subSel').innerHTML=`<option>All Sub Modes</option>`; scale=1; tx=0; ty=0; applyZoom(); SEL_CHOICE.clear(); render(); el('cards').innerHTML=""; CURRENT=[]; el('explainWrap').style.display='none'; };

/* Random picks */
el('rootRnd').onclick=()=>{ if(PMI){
    const all = DB.keys.length? DB.keys : ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
    el('rootSel').value = all[rand(all.length)];
    onRootChange();
  } else {
    if(!DB.keys.length) return; el('rootSel').value=DB.keys[rand(DB.keys.length)]; onRootChange();
  }
};
el('baseRnd').onclick=()=>{ if(PMI) return; const k=val('rootSel'); if(k==="All Keys") return; const bases=Object.keys(DB.data[k]||{}).sort(sortModesCW); if(!bases.length) return; el('baseSel').value=bases[rand(bases.length)]; onBaseChange(); };
el('subRnd').onclick=()=>{ if(PMI) return; const k=val('rootSel'), b=val('baseSel'); if(k==="All Keys"||b==="All Base Modes") return; const subs=uniqueSubsForBase(k,b); if(!subs.length) return; el('subSel').value=subs[rand(subs.length)].value; SEL_CHOICE.clear(); render(); };

/* Hotkeys */
window.addEventListener('keydown',(e)=>{
  const tag=(e.target&&e.target.tagName||'').toLowerCase();
  if(tag==='input' || tag==='select' || tag==='textarea') return;
  const k=e.key;
  if(k>='1' && k<='8'){ const idx=parseInt(k,10)-1; const o=CURRENT[idx]; if(o){ const [root,q]=parseLabel(o.label); const [notes]=build7th(root,q); ctx().resume(); playChord(notes, parseInt(val('vol'))/100); pulseByLabel(o.label); e.preventDefault(); } }
  if(k.toLowerCase()==='g'){ e.preventDefault(); el('gen').click(); }
  if(k.toLowerCase()==='r'){ e.preventDefault(); el('resetAll').click(); }
});

/* Tooltips */
const tip=el('tip');
function setTip(txt,x,y){ tip.textContent=txt; tip.style.left=(x+10)+'px'; tip.style.top=(y+10)+'px'; tip.style.opacity=1; }
function hideTip(){ tip.style.opacity=0; }
svg.addEventListener('mousemove',(e)=>{
  const t=e.target;
  if(t && t.classList && t.classList.contains('n')){
    const txt=t.getAttribute('data-tip')||'';
    if(txt){ setTip(txt,e.clientX,e.clientY); return; }
  }
  hideTip();
});
svg.addEventListener('mouseleave', hideTip);

/* Pan (no wheel zoom) */
let scale=1, tx=0, ty=0, panning=false, start={x:0,y:0};
function applyZoom(){ gZoom.setAttribute('transform',`translate(${tx},${ty}) scale(${scale})`); }
svg.addEventListener('wheel', (e)=>{ e.preventDefault(); }, {passive:false});
svg.addEventListener('mousedown',(e)=>{ panning=true; start={x:e.clientX,y:e.clientY}; });
window.addEventListener('mouseup',()=>{ panning=false; });
window.addEventListener('mousemove',(e)=>{ if(!panning) return; const dx=e.clientX-start.x, dy=e.clientY-start.y; tx+=dx; ty+=dy; start={x:e.clientX,y:e.clientY}; applyZoom(); });
el('zoomIn').onclick = ()=>{ const s2=Math.min(10,scale*1.2); tx=CX-(CX-tx)*(s2/scale); ty=CY-(CY-ty)*(s2/scale); scale=s2; applyZoom(); };
el('zoomOut').onclick= ()=>{ const s2=Math.max(0.05,scale/1.2); tx=CX-(CX-tx)*(s2/scale); ty=CY-(CY-ty)*(s2/scale); scale=s2; applyZoom(); };
el('zoomReset').onclick=()=>{ scale=1; tx=0; ty=0; applyZoom(); };
el('redraw').onclick=render;

/* PMI + Explain toggles */
el('pmiToggle').addEventListener('change', ()=>{
  PMI = el('pmiToggle').checked;
  const baseWrap = el('baseWrap');
  const subWrap  = el('subWrap');
  if(PMI){
    baseWrap.classList.add('hide');
    subWrap.classList.add('hide');
    if(val('rootSel')==="All Keys"){
      const roots = DB.keys.length? DB.keys : ["C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"];
      el('rootSel').innerHTML = roots.map(k=>`<option>${k}</option>`).join("");
      el('rootSel').value = "C";
    }
    refreshChoicesFromPMI();
  } else {
    baseWrap.classList.remove('hide');
    subWrap.classList.remove('hide');
    updateSelectors();
  }
  SEL_CHOICE.clear();
  render();
});
el('explainToggle').addEventListener('change', ()=>{
  EXPLAIN = el('explainToggle').checked;
  renderExplanations();
});

/* Loaders + autoload (unchanged) */
async function loadFromArrayBuffer(ab){
  try{
    const wb=XLSX.read(ab,{type:"array"}); ingestXLSX(wb); updateSelectors(); render();
    el('parseStats').innerHTML = `Sheets: ${DB.stats.sheets}<br>Rows: ${DB.stats.rows}<br>Rows used: ${DB.stats.rowsUsed}<br>Chord cells: ${DB.stats.chordCells}`;
    setInitialDefaults();
  }catch(e){ el('parseStats').textContent='Load failed: '+e.message; console.error(e); }
}
function setInitialDefaults(){
  const rootSel=el('rootSel'); if([...rootSel.options].some(o=>o.value==='C')){ rootSel.value='C'; onRootChange(); } else { onRootChange(); }
  const baseSel=el('baseSel'); const ionBase=[...baseSel.options].find(o=>/ionian/i.test(o.value)); if(ionBase){ baseSel.value=ionBase.value; onBaseChange(); }
  const subSel=el('subSel'); const ionSub=[...subSel.options].find(o=>/ionian\s+ionians/i.test(o.textContent)); if(ionSub){ subSel.value=ionSub.value; render(); }
}
el('file').addEventListener('change', async (ev)=>{ const f=ev.target.files?.[0]; if(!f) return; const ab=await f.arrayBuffer(); await loadFromArrayBuffer(ab); });
el('dataURLLoad').onclick = async ()=>{
  const url=val('dataURL').trim(); if(!url){ el('parseStats').textContent='Enter a URL'; return; }
  try{ el('parseStats').textContent='Loading‚Ä¶'; const res=await fetch(url,{cache:'no-store'}); if(!res.ok) throw new Error('HTTP '+res.status); const ab=await res.arrayBuffer(); await loadFromArrayBuffer(ab); el('settings').style.display='none'; }
  catch(e){ el('parseStats').innerHTML=`Load failed: ${e.message}<br>Tip: CORS can block remote files ‚Äî try another host or the file upload.`; }
};
(function(){
  const p=new URLSearchParams(location.search);
  const url = p.get('xlsx') || 'https://santismo.github.io/ChordWeb/data.xlsx';
  el('dataURL').value = url;
  (async()=>{ try{ el('parseStats').textContent='Loading‚Ä¶'; const r=await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error('HTTP '+r.status); const ab=await r.arrayBuffer(); await loadFromArrayBuffer(ab); } catch(e){ el('parseStats').innerHTML=`Auto-load failed: ${e.message}<br>Open ‚öôÔ∏è Settings to load manually.`; }})();
})();
</script>
</body>
</html>
